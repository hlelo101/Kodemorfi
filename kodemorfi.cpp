#include <iostream>
#include <vector>
#include <fstream>
#include <sstream>
#include <algorithm>

// Variables
const std::string version = "vP-14.06.24";
std::vector<std::string> lines;
std::string parsedCode = "<!-- Generated by Kodemorfi " + version + " -->";
bool executed = false;
char isSyntaxChar = 'n';

//Split string
std::vector<std::string> splitString(const std::string& str, char delimiter) {
    std::vector<std::string> tokens;
    std::stringstream ss(str);
    std::string token;
    
    while (std::getline(ss, token, delimiter)) {
        tokens.push_back(token);
    }
    
    return tokens;
}

//Check if includes word propreties
bool isSyntax(const std::string& word) {
    if(word.size() > 2) {
        std::string lastTwoChars = word.substr(word.size() - 2);
        if(word.size() > 3 && word[0] == '/' && word[2] == '/' && word.back() == '\\') {
            isSyntaxChar = 'n';
            return true;
        } else if (word.size() > 3 && word[0] == '/' && word[2] == '/' && lastTwoChars == "\\?") {
            isSyntaxChar = '?';
            return true;
        } else if (word.size() > 3 && word[0] == '/' && word[2] == '/' && lastTwoChars == "\\!") {
            isSyntaxChar = '!';
            return true;
        } else if (word.size() > 3 && word[0] == '/' && word[2] == '/' && lastTwoChars == "\\.") {
            isSyntaxChar = '.';
            return true;
        } else if(word.size() > 3 && word[0] == '/' && word[2] == '/' && lastTwoChars == "\\:") {
            isSyntaxChar = ':';
            return true;
        } else {
            return false;
        }
    } else {
        return false;
    }
    return false;
}

// Trim string
std::string trimString(const std::string& str, size_t start, size_t end) {
    return str.substr(start, end - start);
}

// Gather array into a string
std::string gatherArrayToString(const std::vector<std::string> array, int from, int to) {
    std::string str;
    for(int i = from; i < to; i++) {
        str = str + array[i] + " ";
    }
    return str;
}

// Check for custom string syntax
std::vector<std::string> checkPipe(std::string& str) {
    std::vector<std::string> result;

    size_t firstPipe = str.find('|');
    while (firstPipe != std::string::npos && firstPipe > 0 && str[firstPipe - 1] == '\\') {
        str.erase(firstPipe - 1, 1); // Remove the escape character
        firstPipe = str.find('|', firstPipe); // Find the next occurrence of "|"
    }

    if (firstPipe != std::string::npos) {
        size_t secondPipe = str.find('|', firstPipe + 2);
        while (secondPipe != std::string::npos && secondPipe > 0 && str[secondPipe - 1] == '\\') {
            str.erase(secondPipe - 1, 1); // Remove the escape character
            secondPipe = str.find('|', secondPipe); // Find the next occurrence of "|"
        }

        if (secondPipe != std::string::npos) {
            size_t lastPipe = str.find('|', secondPipe + 1);
            while (lastPipe != std::string::npos && lastPipe > 0 && str[lastPipe - 1] == '\\') {
                str.erase(lastPipe - 1, 1); // Remove the escape character
                lastPipe = str.find('|', lastPipe); // Find the next occurrence of "|"
            }

            if (lastPipe != std::string::npos) {
                result.push_back("true");
                result.push_back(std::to_string(firstPipe));
                result.push_back(std::to_string(lastPipe));
            } else {
                result.push_back("false");
                result.push_back("0");
                result.push_back("0");
            }
        } else {
            result.push_back("false");
            result.push_back("0");
            result.push_back("0");
        }
    } else {
        result.push_back("false");
        result.push_back("0");
        result.push_back("0");
    }

    return result;
}

void computeLines() {
    for(int i = 0; i!=lines.size(); i++) {
        if(!lines[i].empty()) {
            std::vector<std::string> words = splitString(lines[i], ' ');

            for(int i2 = 0; i2!=words.size(); i2++) { // Custom word syntax check
                if(isSyntax(words[i2])) {
                    if(words[i2].at(1) == 'b') { // Bold word
                        std::cout << "Line " << (i2 + 1) << " word " << (i2 + 1) << ": " << "Bold text. Computing... ";
                        if(isSyntaxChar != 'n') {
                            words[i2] = "<b>" + trimString(words[i2], 3, (words[i2].size() - 2)) + "</b>" + isSyntaxChar;
                        } else {
                            words[i2] = "<b>" + trimString(words[i2], 3, (words[i2].size() - 1)) + "</b>";
                        }
                        lines[i] = gatherArrayToString(words, 0, words.size());
                        std::cout << "Done" << std::endl;
                    }
                    if(words[i2].at(1) == 'i') { // Italic word
                        std::cout << "Line " << (i2 + 1) << " word " << (i2 + 1) << ": " << "Bold text. Computing... ";
                        if(isSyntaxChar != 'n') {
                            words[i2] = "<i>" + trimString(words[i2], 3, (words[i2].size() - 2)) + "</i>" + isSyntaxChar;
                        } else {
                            words[i2] = "<i>" + trimString(words[i2], 3, (words[i2].size() - 1)) + "</i>";
                        }
                        lines[i] = gatherArrayToString(words, 0, words.size());
                        std::cout << "Done" << std::endl;
                    }
                    if(words[i2].at(1) == 'u') { // Underline word
                        std::cout << "Line " << (i2 + 1) << " word " << (i2 + 1) << ": " << "Bold text. Computing... ";
                        if(isSyntaxChar != 'n') {
                            words[i2] = "<u>" + trimString(words[i2], 3, (words[i2].size() - 2)) + "</u>" + isSyntaxChar;
                        } else {
                            words[i2] = "<u>" + trimString(words[i2], 3, (words[i2].size() - 1)) + "</u>";
                        }
                        lines[i] = gatherArrayToString(words, 0, words.size());
                        std::cout << "Done" << std::endl;
                    }
                }
            }

            std::vector<std::string> stringCustomSyntax = checkPipe(lines[i]);
            if(stringCustomSyntax[0] == "true") { // String custom syntax
                bool error = false;
                std::cout << "Line " << (i + 1) << ": " << "String custom syntax. Computing... ";
                // Positions and length 
                int pos1 = std::stoi(stringCustomSyntax[1]);
                int pos2 = (std::stoi(stringCustomSyntax[2]) + 1);
                int length = (std::stoi(stringCustomSyntax[2]) - std::stoi(stringCustomSyntax[1]) - 3);
                std::string inCustomSyntax = trimString(lines[i], (pos1 + 3), (pos1 + length + 3));
                if(lines[i].at(pos1 + 1)=='b') {
                    inCustomSyntax = "<b>" + inCustomSyntax + "</b>";
                } else if(lines[i].at(pos1 + 1)=='i') {
                    inCustomSyntax = "<i>" + inCustomSyntax + "</i>";
                } else if(lines[i].at(pos1 + 1)=='u') {
                    inCustomSyntax = "<u>" + inCustomSyntax + "</u>";
                } else {
                    error = true;
                }
                std::string strPart1 = trimString(lines[i], 0, pos1);
                std::string strPart2 = trimString(lines[i], pos2, lines[i].length());
                lines[i] = strPart1 + inCustomSyntax + strPart2;
                if(!error) {
                    std::cout << "Done" << std::endl;
                } else {
                    std::cout << "Error\nLine " << (i + 1) << ": " << "Unknown syntax" << std::endl;
                }
            }

            if(lines[i].at(0) == '#') { // Big text
                std::cout << "Line " << (i + 1) << ": " << "Big text. Computing... ";
                parsedCode = parsedCode + "<h1>" + lines[i].substr(1) + "</h1>";
                std::cout << "Done" << std::endl;
            } else if(lines[i].at(0) == '\\') { // Escape
                std::cout << "Line " << (i + 1) << ": " << "Escape character. Computing... ";
                parsedCode = parsedCode + "<p>" + lines[i].substr(1) + "</p>";
                std::cout << "Done" << std::endl;
            } else if(lines[i].at(0) == '[' && lines[i].at(2) == ']' || lines[i].at(0) == '[' && lines[i].at(4) == ']') { // Custom font size
                std::cout << "Line " << (i + 1) << ": " << "Custom size text. Computing... ";
                if(lines[i].at(4) == ']') {
                    parsedCode = parsedCode + "<p style=\"font-size: " + lines[i].substr(1, 3) + "em\">" + lines[i].substr(5) + "</p>";
                } else { // Default
                    parsedCode = parsedCode + "<p style=\"font-size: " + lines[i].substr(1, 1) + "em\">" + lines[i].substr(3) + "</p>";
                }
                std::cout << "Done" << std::endl;
            } else if(lines[i].at(0) == '-' && lines[i].length() == 1) { // separator
                parsedCode = parsedCode + "<hr>";
            } else {
                parsedCode = parsedCode + "<p>" + lines[i] + "</p>";
            }
        } else {
            parsedCode = parsedCode + "<br>";
        }
    }

    std::cout << "HTML:\n" << parsedCode << std::endl;
}
int main() {
    bool error = false;
    std::cout << "Kodemorfi " << version << std::endl;
    std::cout << "Reading file... ";
    std::ifstream readFile;
    readFile.open("main.km");
    if (readFile.is_open()) {
        std::cout << "Done" << std::endl;
        std::string line;
        while (std::getline(readFile, line)) {
            lines.push_back(line);
        }
        readFile.close();
        computeLines();
    } else {
        std::cout << "Error\nAn error occured during file opening. Ensure that \"main.km\" is present." << std::endl;
        error = true;
    }
    if(!error) {
        std::cout << "Writing file... ";
        std::ofstream writeFile;
        writeFile.open("kodemorfi_output.html");
        writeFile << parsedCode;
        writeFile.close();
        std::cout << "Done" << std::endl;
    }
    return 0;
}