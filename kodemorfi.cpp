#include <iostream>
#include <vector>
#include <fstream>
#include <sstream>
#include <algorithm>

// Variables
const std::string version = "vD-20.06.24";
std::vector<std::string> lines;
std::string parsedCode = "<!-- Generated by Kodemorfi " + version + " -->";
bool executed = false;
char isSyntaxChar = 'n';

// Find second quote
int findSecondQuote(const std::string str) {
    int firstIndex = -1;
    int secondIndex = 0;

    for (size_t i = 0; i < str.length(); ++i) {
        if (str[i] == '"') {
            if (firstIndex == -1) {
                firstIndex = i;
            } else {
                secondIndex = i;
                break;
            }
        }
    }

    return secondIndex;
}

//Split string
std::vector<std::string> splitString(const std::string& str, char delimiter) {
    std::vector<std::string> tokens;
    std::stringstream ss(str);
    std::string token;
    
    while (std::getline(ss, token, delimiter)) {
        tokens.push_back(token);
    }
    
    return tokens;
}

//Check if includes word propreties
bool isSyntax(const std::string& word) {
    if(word.size() > 2) {
        std::string lastTwoChars = word.substr(word.size() - 2);
        if(word.size() > 3 && word[0] == '/' && word[2] == '/' && word.back() == '\\') {
            isSyntaxChar = 'n';
            return true;
        } else if (word.size() > 3 && word[0] == '/' && word[2] == '/' && lastTwoChars == "\\?") {
            isSyntaxChar = '?';
            return true;
        } else if (word.size() > 3 && word[0] == '/' && word[2] == '/' && lastTwoChars == "\\!") {
            isSyntaxChar = '!';
            return true;
        } else if (word.size() > 3 && word[0] == '/' && word[2] == '/' && lastTwoChars == "\\.") {
            isSyntaxChar = '.';
            return true;
        } else if(word.size() > 3 && word[0] == '/' && word[2] == '/' && lastTwoChars == "\\:") {
            isSyntaxChar = ':';
            return true;
        } else {
            return false;
        }
    } else {
        return false;
    }
    return false;
}

// Trim string
std::string trimString(const std::string& str, size_t start, size_t end) {
    return str.substr(start, end - start);
}

// Gather array into a string
std::string gatherArrayToString(const std::vector<std::string> array, int from, int to) {
    std::string str;
    for(int i = from; i < to; i++) {
        str = str + array[i] + " ";
    }
    return str;
}

// Check for custom string syntax
std::vector<std::string> checkPipe(std::string& str) {
    std::vector<std::string> result;

    size_t firstPipe = str.find('|');
    while (firstPipe != std::string::npos && firstPipe > 0 && str[firstPipe - 1] == '\\') {
        str.erase(firstPipe - 1, 1); // Remove the escape character
        firstPipe = str.find('|', firstPipe); // Find the next occurrence of "|"
    }

    if (firstPipe != std::string::npos) {
        size_t secondPipe = str.find('|', firstPipe + 2);
        while (secondPipe != std::string::npos && secondPipe > 0 && str[secondPipe - 1] == '\\') {
            str.erase(secondPipe - 1, 1); // Remove the escape character
            secondPipe = str.find('|', secondPipe); // Find the next occurrence of "|"
        }

        if (secondPipe != std::string::npos) {
            size_t lastPipe = str.find('|', secondPipe + 1);
            while (lastPipe != std::string::npos && lastPipe > 0 && str[lastPipe - 1] == '\\') {
                str.erase(lastPipe - 1, 1); // Remove the escape character
                lastPipe = str.find('|', lastPipe); // Find the next occurrence of "|"
            }

            if (lastPipe != std::string::npos) {
                result.push_back("true");
                result.push_back(std::to_string(firstPipe));
                result.push_back(std::to_string(lastPipe));
            } else {
                result.push_back("false");
                result.push_back("0");
                result.push_back("0");
            }
        } else {
            result.push_back("false");
            result.push_back("0");
            result.push_back("0");
        }
    } else {
        result.push_back("false");
        result.push_back("0");
        result.push_back("0");
    }

    return result;
}

void computeLines() {
    // Variable for global propreties
    bool boldWords = false;
    bool italicWords = false;
    bool underlineWords = false;
    for(int i = 0; i!=lines.size(); i++) {
        if(!lines[i].empty()) {
            std::vector<std::string> words = splitString(lines[i], ' ');
            if(lines[i].at(0) == '@') { // Global propreties
                bool error = false;
                std::string errReason;
                std::cout << "Line " << (i + 1) << ": " << "Text propreties. Applying... ";
                if(words[0] == "@weight") {
                    if(words[1] == "bold") {
                        boldWords = true;
                    } else if (words[1] == "italic") {
                        italicWords = true;
                    } else if (words[1] == "underline") {
                        underlineWords = true;
                    } else {
                        error = true;
                        errReason = "Unknown syntax.";
                    }
                }
                // Check for conflicts
                if((boldWords && italicWords) || (boldWords && underlineWords) || (italicWords && underlineWords)) {
                    error = true;
                    errReason = "More than two global propreties has been applied. Please ensure that only one global weight proprety has been applied.\n    Global propreties will be ignored.";
                    boldWords = false;
                    italicWords = false;
                    underlineWords = false;
                }
                // Error handling
                if(!error) {
                    std::cout << "Done." << std::endl;
                } else {
                    std::cout << "Error." << std::endl << errReason << std::endl;
                }
            } else {

                for(int i2 = 0; i2!=words.size(); i2++) { // Custom word syntax check
                    if(isSyntax(words[i2])) {
                        if(words[i2].at(1) == 'b') { // Bold word
                            std::cout << "Line " << (i2 + 1) << " word " << (i2 + 1) << ": " << "Bold text. Computing... ";
                            if(isSyntaxChar != 'n') {
                                words[i2] = "<b>" + trimString(words[i2], 3, (words[i2].size() - 2)) + "</b>" + isSyntaxChar;
                            } else {
                                words[i2] = "<b>" + trimString(words[i2], 3, (words[i2].size() - 1)) + "</b>";
                            }
                            lines[i] = gatherArrayToString(words, 0, words.size());
                            std::cout << "Done" << std::endl;
                        }
                        if(words[i2].at(1) == 'i') { // Italic word
                            std::cout << "Line " << (i2 + 1) << " word " << (i2 + 1) << ": " << "Bold text. Computing... ";
                            if(isSyntaxChar != 'n') {
                                words[i2] = "<i>" + trimString(words[i2], 3, (words[i2].size() - 2)) + "</i>" + isSyntaxChar;
                            } else {
                                words[i2] = "<i>" + trimString(words[i2], 3, (words[i2].size() - 1)) + "</i>";
                            }
                            lines[i] = gatherArrayToString(words, 0, words.size());
                            std::cout << "Done" << std::endl;
                        }
                        if(words[i2].at(1) == 'u') { // Underline word
                            std::cout << "Line " << (i2 + 1) << " word " << (i2 + 1) << ": " << "Bold text. Computing... ";
                            if(isSyntaxChar != 'n') {
                                words[i2] = "<u>" + trimString(words[i2], 3, (words[i2].size() - 2)) + "</u>" + isSyntaxChar;
                            } else {
                                words[i2] = "<u>" + trimString(words[i2], 3, (words[i2].size() - 1)) + "</u>";
                            }
                            lines[i] = gatherArrayToString(words, 0, words.size());
                            std::cout << "Done" << std::endl;
                        }
                    }
                }
                std::vector<std::string> stringCustomSyntax = checkPipe(lines[i]);
                if(stringCustomSyntax[0] == "true") { // String custom syntax
                    bool error = false;
                    std::cout << "Line " << (i + 1) << ": " << "String custom syntax. Computing... ";
                    // Positions and length 
                    int pos1 = std::stoi(stringCustomSyntax[1]);
                    int pos2 = (std::stoi(stringCustomSyntax[2]) + 1);
                    int length = (std::stoi(stringCustomSyntax[2]) - std::stoi(stringCustomSyntax[1]) - 3);
                    std::string inCustomSyntax = trimString(lines[i], (pos1 + 3), (pos1 + length + 3));
                    if(lines[i].at(pos1 + 1)=='b') {
                        inCustomSyntax = "<b>" + inCustomSyntax + "</b>";
                    } else if(lines[i].at(pos1 + 1)=='i') {
                        inCustomSyntax = "<i>" + inCustomSyntax + "</i>";
                    } else if(lines[i].at(pos1 + 1)=='u') {
                        inCustomSyntax = "<u>" + inCustomSyntax + "</u>";
                    } else {
                        error = true;
                    }
                    std::string strPart1 = trimString(lines[i], 0, pos1);
                    std::string strPart2 = trimString(lines[i], pos2, lines[i].length());
                    lines[i] = strPart1 + inCustomSyntax + strPart2;
                    if(!error) {
                        std::cout << "Done" << std::endl;
                    } else {
                        std::cout << "Error\nLine " << (i + 1) << ": " << "Unknown syntax" << std::endl;
                    }
                }
                if(lines[i].at(0) == '#') { // Big text
                    std::cout << "Line " << (i + 1) << ": " << "Big text. Computing... ";
                    parsedCode = parsedCode + "<h1>" + lines[i].substr(1) + "</h1>";
                    std::cout << "Done" << std::endl;
                } else if(lines[i].at(0) == '\\') { // Escape
                    std::cout << "Line " << (i + 1) << ": " << "Escape character. Computing... ";
                    parsedCode = parsedCode + "<p>" + lines[i].substr(1) + "</p>";
                    std::cout << "Done" << std::endl;
                } else if(lines[i].at(0) == '[' && lines[i].at(2) == ']' || lines[i].at(0) == '[' && lines[i].at(4) == ']') { // Custom font size
                    std::cout << "Line " << (i + 1) << ": " << "Custom size text. Computing... ";
                    std::string tag = "p";
                    if(boldWords) {
                        tag = "b><br";
                    } else if(italicWords) {
                        tag = "i><br";
                    } else if(underlineWords) {
                        tag = "u><br";
                    }
                    if(lines[i].at(4) == ']') {
                        parsedCode = parsedCode + "<" + trimString(tag, 0, 1) + " style=\"font-size: " + lines[i].substr(1, 3) + "em\">" + lines[i].substr(5) + "</" + tag + ">";
                    } else { // Default
                        parsedCode = parsedCode + "<" + trimString(tag, 0, 1) + " style=\"font-size: " + lines[i].substr(1, 1) + "em\">" + lines[i].substr(3) + "</" + tag + ">";
                    }
                    std::cout << "Done" << std::endl;
                } else if(lines[i].at(0) == '-' && lines[i].length() == 1) { // separator
                    parsedCode = parsedCode + "<hr>";
                } else if(lines[i].at(0) == '!') { // Images
                    bool error = false;
                    std::cout << "Line " << (i + 1) << ": " << "Image. Computing... ";
                    if(!findSecondQuote(lines[i]) == 0) {
                        parsedCode = parsedCode + "<img src=\"" + trimString(lines[i], 5, findSecondQuote(lines[i])) + "\">";
                    } else {
                        error = true;
                    }
                    if(!error) {
                        std::cout << "Done" << std::endl;
                    } else {
                        std::cout << "Error." << std::endl;
                    }
                } else {
                    if(boldWords) {
                        parsedCode = parsedCode + "<b>" + lines[i] + "</b>" + "<br>";
                    } else if(italicWords) {
                        parsedCode = parsedCode + "<i>" + lines[i] + "</i>" + "<br>";
                    } else if(underlineWords) {
                        parsedCode = parsedCode + "<u>" + lines[i] + "</u>" + "<br>";
                    } else {
                        parsedCode = parsedCode + "<p>" + lines[i] + "</p>";
                    }
                }
            }
        } else {
            parsedCode = parsedCode + "<br>";
        }
    }

    std::cout << "HTML:\n" << parsedCode << std::endl;
}
int main() {
    bool error = false;
    std::cout << "Kodemorfi " << version << std::endl;
    std::cout << "Reading file... ";
    std::ifstream readFile;
    readFile.open("main.km");
    if (readFile.is_open()) {
        std::cout << "Done" << std::endl;
        std::string line;
        while (std::getline(readFile, line)) {
            lines.push_back(line);
        }
        readFile.close();
        computeLines();
    } else {
        std::cout << "Error\nAn error occured during file opening. Ensure that \"main.km\" is present." << std::endl;
        error = true;
    }
    if(!error) {
        std::cout << "Writing file... ";
        std::ofstream writeFile;
        writeFile.open("kodemorfi_output.html");
        writeFile << parsedCode;
        writeFile.close();
        std::cout << "Done" << std::endl;
    }
    return 0;
}